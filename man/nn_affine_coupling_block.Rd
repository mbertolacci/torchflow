% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coupling.R
\name{nn_affine_coupling_block}
\alias{nn_affine_coupling_block}
\title{Affine Coupling Block}
\usage{
nn_affine_coupling_block(
  input_size,
  conditioning_size = 0,
  left_size = as.integer(input_size\%/\%2),
  f_scale,
  f_shift,
  g_scale,
  g_shift,
  soft_clamp = 1.9
)
}
\arguments{
\item{input_size}{The dimension of the input. The input itself is a tensor
with dimensions \verb{[batch_size, input_size]}, or just \verb{[input_size]} if there
is no batch dimension.}

\item{conditioning_size}{The dimension of the conditioning input, which has
the same batch dimensions as the input.}

\item{left_size}{The dimension of the left part of the input (the split
\eqn{x_1} in the equations above).}

\item{f_scale}{The function \eqn{f_\text{scale}} in the equations above. This,
and the following parameters, default to a conditional multi-layer
perceptron (MLP); see \code{\link[=nn_conditional_mlp]{nn_conditional_mlp()}}. It must inherit from
\code{\link[=nn_conditional]{nn_conditional()}}.}

\item{f_shift}{The function \eqn{f_\text{shift}} in the equations above; see
the above.}

\item{g_scale}{The function \eqn{g_\text{scale}} in the equations above; see
the above.}

\item{g_shift}{The function \eqn{g_\text{shift}} in the equations above; see
the above.}

\item{soft_clamp}{The soft clamp value for the scale parameters.}
}
\description{
An affine coupling block is a conditional flow inheriting from
\code{\link[=nn_conditional_flow]{nn_conditional_flow()}} that applies the following transformation to the
input.
}
\details{
Let \eqn{x = (x_1, x_2)} be a split of the input into two parts, and let
\eqn{u} be the conditioning input. The forward transformation is given by:

\deqn{
  y_1 = x_1 \exp(f_\text{scale}(x_2, u)) + f_\text{shift}(x_2, u)
  y_2 = x_2 \exp(g_\text{scale}(y_1, u)) + g_\text{shift}(y_1, u)
}

The inverse transformation is given by:

\deqn{
  x_1 = y_1 \exp(g_\text{scale}(y_2, u)) + g_\text{shift}(y_2, u)
  x_2 = y_2 \exp(f_\text{scale}(x_1, u)) + f_\text{shift}(x_1, u)
}

The log determinant of the Jacobian of the transformation is given by:

\deqn{
  \log | \det \frac{\partial y}{\partial x} |
   = \sum_{i=1}^2 f_\text{scale}(x_i, u) + g_\text{scale}(y_i, u)
}

By performing multiple such transformations in sequence, we can construct a
complex normalizing flow capable of modeling complicated conditional
distributions. Between each pair of such transformations, the dimensions of
the input should be permuted using a \code{\link[=nn_permutation_flow]{nn_permutation_flow()}}.
}
\examples{
library(torch)
# Coupling block used on its own with no conditioning
flow_model <- nn_affine_coupling_block(2, 0)
x <- torch_randn(10, 2)
y <- flow_model(x)
# y will be a tensor of dimensions [10, 2]
x_recovered <- flow_model$reverse(y)
# x_recovered will be a tensor of dimensions [10, 2]
# and numerically close to the original x

# Coupling block used with conditioning
flow_model <- nn_affine_coupling_block(2, 4)
x <- torch_randn(10, 2)
u <- torch_randn(10, 4)
y <- flow_model(x, u)
# y will be a tensor of dimensions [10, 2]
x_recovered <- flow_model$reverse(y, u)
# x_recovered will be a tensor of dimensions [10, 2]
# and numerically close to the original x

# Coupling block used as part of a more complex flow model
flow_model <- nn_sequential_conditional_flow(
  nn_affine_coupling_block(2, 4),
  nn_permutation_flow(2),
  nn_affine_coupling_block(2, 4)
)
y <- flow_model(x, u)

}
